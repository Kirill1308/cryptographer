package org.javarush.cipher.caesar.command;

import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;

class HackCommandTest {
    @Test
    void processContent_emptyContent() {
        HackCommand hackCommand = new HackCommand("");
        String result = hackCommand.processContent("");
        assertEquals("", result, "Expected decrypted content to be empty for empty input");
    }

    @Test
    void processContent_singleCharacterEncrypted() {
        HackCommand hackCommand = new HackCommand("");
        String result = hackCommand.processContent("kyvtrmrcipnzccrkkrtbwifdkyvefikynvjkrkeffe");
        assertEquals("thecavalrywillattackfromthenorthwestatnoon", result, "Expected decrypted content to be 'A' for single character encrypted 'A'");
    }

    @Test
    void testGetDestFilePath() {
        String testFilePath = "C:\\test\\sample.txt";
        HackCommand hackCommand = new HackCommand(testFilePath);

        String expectedFilePath = "C:\\test\\sample.txt[HACKED]";

        assertEquals(expectedFilePath, hackCommand.getDestFilePath(testFilePath),
                "Expected filepath does not match with the filepath generated by getDestFilePath method");
    }

//    @Test
//    void processContent_multipleCharactersEncrypted() {
//        HackCommand hackCommand = new HackCommand("path/to/file");
//        String result = hackCommand.processContent("B FO UIF CFHJOOJOH, BMM XBT XJHI");
//        assertEquals("A EO THE BEGINNING, ALL VAT WIHI", result, "Expected decrypted content to match the specific decrypted version of the encrypted input string");
//    }
}
